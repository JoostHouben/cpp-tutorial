\documentclass[12pt,a4paper]{article}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{amssymb, amsmath}
\usepackage{fancyhdr}
\usepackage{footnote}
\usepackage{hyperref}
\usepackage[justification=centering]{caption}
\usepackage{enumerate}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{bm}
\usepackage{siunitx}
\usepackage[usenames,dvipsnames]{color}
\pagestyle{fancy}
\setlength{\headheight}{15pt}
\setlength{\parindent}{0pt}

\renewcommand{\thesection}		{\arabic{section}}
\renewcommand{\thesubsection}	{\arabic{subsection}}

\usepackage{listings}
\lstset{
    language=C++,
    tabsize=4,
    frame=lines,
    numbers=left,
    numberstyle=\color{black}\tiny,
    numbersep=8pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\color{black}\footnotesize\ttfamily,
	identifierstyle=\color{black},
	keywordstyle=\bfseries\color{blue}\bfseries,
	commentstyle=\color{OliveGreen},
	stringstyle =\color{red},
}

% \code to include a file
% \icode to create inline code
\newcommand{\code}{\lstinputlisting}
\newcommand{\icode}{\lstinline}
\newcommand{\mono}{\texttt}

\fancyhead[R]{}
\fancyfoot[C]{\thepage}

\title{Inleiding programmeren in C++}
\author{
FysiCie\\
i.s.m.\\
Ragnar Groot Koerkamp
}
\date{18 juni 2015}
 
%\renewcommand{\contentsname}{Inhoud}

\newcommand{\cpp}{\mono{C++ }}
 
\begin{document}
 
\maketitle

\tableofcontents

\clearpage
\subsection{Overzicht}
In deze cursus leer je de basis van programmeren in \cpp. We beginnen bij het opstarten van een project in een tekstverwerker. Daarna gaan we in op de structuur van een programma en wat de regels zijn bij het schrijven ervan. Vervolgens wordt aan de hand van veel voorbeelden en simpele opdrachten de basis van \cpp zelf	 uitgelegd. We gaan hierbij bijvoorbeeld in op variabelen, \icode{if}-statements en \icode{for}-loops.

Na afloop van deze cursus zou je van onderstaande code moeten kunnen achterhalen wat het doet en hoe het werkt:

\code{code/eind.cpp}

Deze pdf en alle gebruikte code zijn beschikbaar op \url{http://github.com/RagnarGrootKoerkamp/cpp-tutorial}. De voorbeelden die in de pdf staan kun je zelf uitvoeren om te ontdekken wat ze precies doen. We raden je sterk aan om in het begin alle code uit de voorbeelden over te typen uit de pdf, zodat je enigszins gedwongen wordt om goed naar het voorbeeld te kijken. Op die manier leer je het snelst! 

\subsection{Compilers}
Een computer heeft heel veel rekenkracht en hier kunnen zeker natuurkundigen nuttig gebruik van maken. Met behulp van een computer kunnen we bijvoorbeeld numerieke oplossingen vinden van vergelijkingen die geen analytische oplossing hebben. Maar om de computer iets voor ons te laten uitrekenen, zullen we hem moeten vertellen wat hij precies moet doen. We moeten dus tegen de computer kunnen `praten,' en dit praten gebeurt in een \emph{programmeertaal}. Er zijn verschillende programmeertalen zoals C, {\cpp,} Java en Python. Een computerprogramma schrijven we in zo'n programmeertaal. De computer kan echter deze programmeertalen nog niet direct begrijpen, daarvoor is nog een extra tussenstap nodig. De broncode, geschreven door ons in een programmeertaal, moet worden vertaald naar \emph{machinecode}. Deze machinecode bevat de opdrachten die de processor moet uitvoeren. Een \emph{compiler} vertaalt de programmeertaal naar machinecode. Voor iedere programmeertaal bestaan er compilers die die specifieke programmeertaal naar machinecode vertalen.

Er zijn verschillende \cpp compilers. Veel compilers moet je installeren op je computer. Dat gaan we vandaag niet doen. In plaats daarvan gaan we gebruik maken van Cloud9, dat is een compiler in een cloud. Deze kun je vinden op \url{http://c9.io}. Verdere uitleg over hoe je precies gebruik maakt van deze compiler vind je bij de eerste opgave.

\subsection{Basis}
We bekijken nu eerst hoe een programma globaal in elkaar zit.  Elk programma heeft een \icode{main} functie. Bij het uitvoeren van het programma wordt als eerste alles wat in de \icode{main} functie staat uitgevoerd. Dit gebeurt regel voor regel, van boven naar beneden. Vandaag staat alle code in de \icode{main} functie, dus tussen de accolades die aangeven welke code bij de \icode{main} hoort.

Bovenaan het programma zie je groene regels \emph{commentaar} staan die beginnen met \icode{//}. Deze regels worden altijd overgeslagen bij het uitvoeren van het programma. Het commentaar begint pas bij de \icode{//}, dus ervoor kan nog wel code staan. Het is handig om commentaar bij de code te zetten om te verduidelijken wat de code doet. Dat is handig als je ergens later weer naar terug kijkt en dan niet opnieuw hoeft uit te zoeken wat de code nou eigenlijk deed. Commentaar kan ook meer dan \'e\'en regel omvatten. Dan gebruik je aan het begin \icode{/*} en aan het einde \icode{*/}. Hieronder staat een voorbeeld van een basis voor een programma. 

\code{code/template.cpp}

In \cpp moeten de meeste regels met een \emph{puntkomma} (\icode{;}) eindigen. Dat is nodig zodat de compiler weet wanneer een nieuwe regel met nieuwe code begint. Alleen in sommige gevallen zijn geen puntkomma's nodig, zoals direct na een accolade of achter een \icode{#include}.

In \cpp  mag je overal zo veel witruimte (spaties, tabs, enters) neerzetten als je maar wilt. De enige eis is dat sommige dingen niet direct aan elkaar geschreven morgen worden, en er dus minstens een spatie tussen moet zitten.

Verder zie je ook nog \icode{#include <iostream>} staan. \icode{<iostream>} is een pakketje dat we later nodig zullen hebben om tekst te schrijven naar de console en om data in te lezen.
(De \emph{console} is een scherm waar je output naar toe kunt schrijven en waar je input uit terug kunt vragen. Bij Cloud9 is dat het schermpje dat onder in je beeldscherm staat, zoals je straks vanzelf zult zien.)
Alle functies in \icode{<iostream>} behoren tot de \cpp-standaard-library. Om ze makkelijk te gebruiken moeten we \icode{using namespace std;} bovenaan onze code zetten.

Let op het gebruik van hoofdletters en kleine letters in de code. \cpp is \emph{hoofdlettergevoelig}, dus \icode{Int} is niet hezelfde als \icode{int}!


\paragraph{Opdrachten}

\begin{enumerate}
	\item 
		Om Cloud9 te gebruiken volg je de volgende stappen: 
		\begin{enumerate} 
			\item Ga naar Cloud9 op \url{http://c9.io/}. Maak een account aan. 
			\item Als je ingelogd bent, klik je op `create workspace' en vervolgens weer op `create workspace'. 
			\item Kies een leuke naam voor je workspace. 
			\item Selecteer C/\cpp, de rest kun je laten staan zoals het nu staat. 
			\item Klik op `create' en wacht even. (Het duurt even voordat de workspace is gemaakt, ook al spring je direct weer terug naar het dashboard.) 
			\item Klik links onder `my projects' op de workspace die je net hebt gecreÃ«erd. Wacht even tot er `start editing' staat en klik hierop. 
			\item Ga vervolgens naar `File' en klik op `New File'. 
			\item Sla op met CTRL + S en verander de naam van de file naar \mono{hallo.cpp}. De naam van je programma mag altijd alleen letters en underscores bevatten. De \mono{.cpp} zorgt ervoor dat de compiler weet dat het een \cpp programma is. (De \mono{p}'s staan voor \emph{plus}.)
		\end{enumerate} 

		
	\item 
		Type nu de code uit het bovenstaande voorbeeld over in het bestand \mono{hallo.cpp}, maar laat het commentaar nog even weg. Start het programma door op `Run' bovenaan in de werkbalk te klikken. Als alles goed gaat zie je nu onderin het beeld een blauw schermpje met de tekst `Running /home/ubuntu/workspace/hallo.cpp'. Omdat het programma nog niets doet, staat hier nog geen uitvoer onder.
	\item
		Voeg nu ook commentaar toe op de plekken waar dat in het voorbeeld ook is gedaan. Check dat het programma nog steeds werkt.
	\item
		Probeer nu ook om \textbf{binnen} \icode{main} je eigen commentaar toe te voegen van beide soorten, dus met \icode{//} en \icode{/* */}.
	\item 
		Voeg nu nogmaals commentaar toe in de vorm van een blok (dus van de soort \icode{/* */}) toe, maar doe dit nu ergens midden in een code regel, dus bijvoorbeeld tussen \icode{int} en \icode{main()}. Omdat witruimte niet van belang is en het commentaar wordt weggegooid, zou je programma nog steeds moeten werken.
\end{enumerate}

\subsection{Console uitvoer}
Bij Cloud9 staat onderaan je beeldscherm een breed, rechthoekig blauw schermpje. Dat heet de \emph{console} of \emph{terminal}. Dit kan ook een zwart popup-venster zijn of een linux-terminal, afhankelijk van de programmeeromgeving. Vandaag houden we het echter bij Cloud9. In de console kunnen we tekst wegschrijven of juist lezen. Het neerzetten van tekst kan met het commando \icode{cout}, oftewel, Console-out. Je kan achter de \icode{cout <<} bijvoorbeeld een tekst of een getal zetten. Ook is er het speciale commando \icode{endl}, dat voor \emph{endline} staat. Hiermee be\"eindig je dus een regel. Het is handig om te onthouden dat je de tekst `in de console stopt' en de pijltjes dus richting \icode{cout} staan.

De \emph{syntax} van een programmeertaal omvat de spellingsregels/taalregels van de programmeertaal. De syntax beschrijft dus hoe je een bepaalde opdracht die je aan de computer wilt geven op moet schrijven. De algemene syntax van cout is:\\

\icode{cout << } \emph{string, cijfer, of nog iets anders} \icode{;}\\

Hierbij staat de tekst `string, cijfer, of nog iets anders' schuingedrukt, omdat je deze niet letterlijk zo in je programma mag zetten. Hier moet je bij het schrijven van je programma nog een specifieke invulling aan geven. Het is soms handig om meer dan \'e\'en ding tegelijk te kunnen schrijven. Dat kan met behulp van:\\

\icode{cout << } \emph{string, cijfer, of nog iets anders} \icode{ << } \emph{andere string, cijfer, etc} \icode{ << } .. \icode{;}

\code{code/cout.cpp}

\paragraph{Opdrachten}
\begin{enumerate}
		\item
			Neem het bovenstaande voorbeeld over. Maak eerst van de regel waarop $22$ wordt weggeschreven commentaar, en maak vervolgens van de twee regels voor het wegschrijven van de datum blok-commentaar.
		\item
			Haal nu de \texttt{;} aan het einde van regel 7\footnote{De regelnummers verwijzen naar de code in het voorbeeld hierboven. Het kan zijn dat de regelnummers in jouw code net anders zijn. Kies dan steeds de overeenkomstige regel.} weg. Als je het programma probeert uit te voeren krijg je nu een foutmelding\footnote{Na het printen van de foutmelding voert cloud9 automatisch de laatste goede versie van het programma uit, negeer dit voor nu maar even.}. Het is waarschijnlijk iets in de trant van:
			\begin{verbatim}
/home/ubuntu/workspace/hallo.cpp: In function âint main()â:                                                                                                      
/home/ubuntu/workspace/hallo.cpp:16:1: error: expected â;â before â}â token                                                                                      
}                                                                                                                                                               
^
			\end{verbatim}
			De compiler geeft hier aan dat er ergens een puntkomma mist. Op de eerste regel van de foutmelding zegt de compiler dat de fout in de functie \texttt{main} zit. Op de tweede regel zegt de compiler dat hij op regel 16, bij het eerste teken, een fout tegenkomt. De fout is dat er voor de accolade ergens nog een puntkomma zou moeten komen. De laatste twee regels geven een soort van visuele weergave van waar de fout zit. \\
			Waarom komt de foutmelding niet bij regel 7? \\
			Probeer de foutmelding op te lossen door iets neer te zetten op regel 15. \\
			Haal nu de laatste \texttt{<} weg van regel 7 (Ã©Ã©ntje maar). Je krijgt nu een \emph{veel} langere foutmelding, maar de belangrijkste informatie staat helemaal bovenaan. Los de fout weer op en ga verder met de volgende opdracht.
		\item
			Schrijf nu alleen de tekst ``How are you?'' naar de console in plaats van ``Mijn leeftijd is''.
		\item
			In plaats van twee dingen op \'e\'en regel weg te schrijven, kunnen we ook twee regels gebruiken. Verander de regel code die je bij de vorige vraag hebt toegevoegd naar de twee regels \icode{cout << "How are you?";} en \icode{cout << endl;}. Je ziet dat er nog steeds hetzelfde gebeurt als je het programma uitvoert.
		\item
			Zorg nu dat het programma twee keer ``How are you?'' zegt, op twee regels onder elkaar.
		\item
			Kan je er ook voor zorgen dat er op \'e\'en regel twee keer ``How are you'' komt te staan.
		\item
			Print nu de lijst getallen van 1 tot en met 5, waarbij elk getal op zijn eigen regel staat.
		\item
			We kunnen die getallen ook op \'e\'en regel zetten door steeds \icode{endl} te vervangen door \icode{" "}. Probeer dit eens uit.
		\item
			Zorg er nu voor dat je in je code maar \'e\'en keer het woord \icode{cout} gebruikt.
			Zoals je ziet kunnen we in het programma er op \'e\'en regel zowel voor zorgen dat er getallen als tekst naar de console worden geschreven. 
\end{enumerate}

\subsection{Variabelen}
Er zijn meerdere soorten variabelen. De belangrijkste zijn getallen en strings. Een getal kan of geheel zijn, of re\"eel. In het eerste geval gebruiken we een \icode{int}, wat staat voor \emph{integer}. Als een getal niet altijd geheel is, hebben we een \icode{double} nodig. Een double kan elke mogelijke waarde aannemen, dus bijvoorbeeld ook $1.2$ of $\sqrt 2$.\\
Een \icode{string} is een stuk tekst. In computertaal is dat gewoon een rij van tekens. Verder hebben we nog \icode{bool}s. Dat zijn waarden die waar (\icode{true}) of onwaar (\icode{false}) zijn.

\subsubsection{Strings}

Strings zijn tekstvariabelen. Een tekstvariabele moet altijd tussen aanhalingstekens \icode{" "} staan. 
Bijvoorbeeld: 

\begin{lstlisting}
#include <iostream> 

int main() {
 string naam = "Piet"; // Deze regel wordt in het volgende stukje uitgelegd! 
 cout << "Mijn naam is " << naam << endl;
 cout << "Mijn naam is " << "Piet" << endl; 
}
\end{lstlisting}

\paragraph{Opdrachten}
\begin{enumerate} 
\item 
Print `Mijn naam is ... ' en vul op de puntjes je eigen naam in. Maak hierbij gebruik van een variabele waarin je eerst je eigen naam opslaat! 
\end{enumerate} 

\subsubsection{Declaratie en initializatie}
Voordat we aan een variabele een waarde kunnen toekennen, moeten we deze \emph{declareren} (Engels: \emph{declaration}). 
Hierbij moeten we specifiek aangeven van welk datatype (\icode{int}, \icode{double}, \icode{bool}, 
\icode{string}) een variabele is. Dit datatype staat daarna vast en kan niet meer veranderd worden.
Het is verplicht om iedere variabele te declareren en dit declareren mag je maar Ã©Ã©n keer doen. 
De syntax van een declaratie is als volgt

\icode{datatype naam;} 

Bijvoorbeeld met \icode{int a;} declareer je een variabele genaamd \icode{a} van het datatype 
\icode{int} (geheel getal). We kunnen met gebruik van de `='-operator een waarde toekennen aan een variabele. Dit heet ook wel de \emph{initialisatie} (Engels: \emph{initialization}).
Dat gaat als volgt: \icode{a = 2;}. De variabele \icode{a} heeft nu de waarde 2.
Variabelen kunnen op twee manieren gedeclareerd worden. De variabele kan gedeclareerd worden 
voordat de variabele ge\"initialiseerd wordt, of de declaratie en de initialisatie gebeuren tegelijk. 
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main(){
	// Eerst declareren, dan toekenning 
	int a; 
	a = 2; 
	cout << a << endl; 
	// Declaratie en toekenning tegelijk
	int b = 3; 
	cout << b << endl; 
}
\end{lstlisting}
Hoewel een variabele maar Ã©Ã©n keer gedeclareerd kan worden en het datatype daarna vaststaat, kan 
wel de waarde van de variabele later in het programma worden aangepast. De eerste keer dat een variabele een waarde krijgt noemen we dat, zoals eerder genoemd, de initialisatie. Alle keren daarna, als de variabele een nieuwe waarde krijgt, noemen we het een \emph{toekenningsopdracht}. We kunnen de variabele \icode{a} een nieuwe waarde toekennen op dezelfde manier als waarop hij zijn eerste waarde krijgt. 
\begin{lstlisting}
#include <iostream> 
using namespace std;
int main() {
	int a; 
	a = 2; 
	cout << "a = " << a << endl; 
	a = 3; 
	cout << "a = " << a << endl; // a heeft nu een nieuwe waarde, namelijk 3! 
}
\end{lstlisting}
Voor \icode{double}s werkt dit hetzelfde als voor \icode{int}s behalve dat je bij de declaratie moet 
aangeven dat het een \icode{double} is in plaats van een \icode{int}. 
\paragraph{Opdrachten}
\begin{enumerate} 
\item 
	Declareer een \icode{double} genaand \icode{pi} en initialiseer deze met de waarde $3.1415$. 
Print de waarde van \icode{pi} vervolgens naar de console. 
\item 
	Laat de code die je al hebt staan. Voeg nog een paar regels extra code toe waarin je de waarde van \icode{pi} een verandert naar de waarde $3.14159265$ en print ook de nieuwe waarde naar de console. 
nogmaals de waarde van \icode{pi} naar de console. 
\end{enumerate} 

\subsubsection{Rekenen met \icode{int}s en \icode{double}s}

We kunnen met \icode{int}s en \icode{double}s rekenen door het gebruik van de operatoren + - * /. 
De + - * operatoren werken precies zoals je zou verwachten. Onderstaand voorbeeld illustreert dit. (Vergeet niet de voorbeelden steeds over te nemen en ze zelf uit te proberen om te zien wat voor uitvoer de code precies geeft!) 
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main () {
	int a = 2; 
	int b = 3; 
	cout << "a + b = " << a + b << endl; 
	cout << "a - b = " << a - b << endl; 
	cout << "a * b = " << a * b << endl; 
}
\end{lstlisting}
Bij deling werkt dit iets anders. Bij het delen van gehele getallen wordt het resultaat namelijk altijd naar beneden afgerond. 
Onderstaand voorbeeld illustreert dit.
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main () {
	int a = 3; 
	int b = 2; 
	cout << "a/b = " << a/b << endl; 
}
\end{lstlisting}
Uit de berekening $\frac 32$ komt in dit geval $1$, omdat $1.5$ naar beneden wordt afgerond. Bij een 
berekening waarbij alleen \icode{int}s worden gebruikt wordt het resultaat van de berekening ook 
een \icode{int} en bij deze deling wordt $\frac 32$ dus naar beneden afgerond naar de integer 1. Als je minstens 
Ã©Ã©n \icode{double} gebruikt bij je berekening wordt het resultaat een \icode{double} en voorkom je 
die afronding naar beneden (als je dat niet wilt tenminste). 
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main () {
	double a = 3; 
	double b = 2; 
	cout << "a/b = " << a/b << endl; 
}
\end{lstlisting}

\paragraph{Opdrachten}
\begin{enumerate}
\item
	Een fietsen doet er 10 seconde over om een afstand van 75 meter af te leggen. Print zijn snelheid in meter per seconde naar de console, door deze met een deling uit te rekenen. (Niet met je rekenmachine, maar door te programmeren natuurlijk.) 
\item 
	Wat is de snelheid in kilometer per uur? (Weer door het uit te programmeren!)
\end{enumerate} 

\subsubsection{Meer operatoren}
Het gebeurt vaak dat je een variabele wilt ophogen met een vaste waarde. Stel je wilt de 
variabele \icode{a} uit het vorige voorbeeld met 2 ophogen, dan kun je dat als volgt doen: \icode{a = a + 2}. Dit ziet er misschien raar uit, maar wat hier staat (in computertaal) is: ``De nieuwe waarde 
van a \emph{wordt} gelijk aan de oude waarde van a plus 2ââ. Hierin zijn de \icode{a} voor het 
gelijkheidsteken en de \icode{a} na het gelijkheidsteken dus niet hetzelfde, hoewel het om dezelfde 
variabele gaat. De \emph{waarde} van \icode{a} voor het gelijkheidsteken betreft de nieuwe waarde 
van \icode{a} en de \icode{a} na het gelijkheidsteken betreft zijn oude waarde. Een verkorte notatie
voor deze ophoging is \icode{a += 2}.
Deze verkorte notatie kan ook gebruikt worden voor -, * en /.
Specifiek voor als je een variabele wilt ophogen met de waarde 
1 bestaat er een nog kortere notatie: \icode{a = a + 1} is hetzelfde als \icode{a++}. 
Analoog hieraan verlaagt \icode{a--} de waarde van \icode{a} met $1$.
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main () 
{
	int a = 2; 
	a = a + 3; // a wordt met 3 opgehoogd
	cout << a << endl; 
	a += 3; // a wordt weer met 3 opgehoogd 
	cout << a << endl; 
}
\end{lstlisting}
Bovenstaande geldt allemaal ook voor \icode{double}s. Wat nu als je een wortel of een sinus wilt gebruiken 
in je berekening? Daarvoor hebben we het pakketje \icode{<cmath>} nodig dat veel handige functies 
bevat zoals \icode{sqrt}, \icode{sin}, \icode{cos}, \icode{exp}, \icode{log} etc. Een voorbeeldje: 
\begin{lstlisting}
#include <iostream> 
#include <cmath>
using namespace std; 
int main () {
	double getal = 25; 
	cout << sqrt(getal) << endl; 
}
\end{lstlisting}
\paragraph{Opdrachten}
\begin{enumerate} 
\item 
Print de sinus van $\pi/2$ (zoek op `cmath C++â om alle functies te vinden die in dit 
pakketje zitten, en kies de juiste!). 
\end{enumerate} 
\subsubsection{Booleans}
Een boolean of \icode{bool} is een variabele die slechts twee waarden kan aannemen, \icode{true} of 
\icode{false} (ook wel aangeduid met respectievelijk 1 en 0). Bij het testen of twee variabelen gelijk 
zijn aan elkaar is het resultaattype een boolean, ze zijn ofwel gelijk aan elkaar (true) of niet gelijk aan 
elkaar (false).
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main() {
	bool t = true;
	bool f = false; 
	// bools worden geprint als 1 of 0! 
	cout << "t:\t" << t << endl; // \t zorgt voor een tab
	cout << "f:\t" << f << endl; 
}
\end{lstlisting}

We kunnen testen of twee variabelen gelijk zijn aan elkaar met een dubbel gelijkheidsteken (\icode{==}). 
\begin{lstlisting}
#include <iostream> 
using namespace std;
int main () {
	cout << (2 == 2) << endl; 
	double x = 3.2; 
	double y = 4.5; 
	cout << (x == y) << endl; 
}
\end{lstlisting}
Naast de logische operator \icode{==} voor het testen van gelijkheid bestaan ook de operator \icode{!} die staat voor 
logische negatie. Dat betekent dat \icode{!false} gelijk is aan \icode{true}, en dat \icode{!true} weer \icode{false} wordt.
Met \icode{!=} kun je testen of twee dingen \emph{niet} gelijk zijn aan elkaar. 
\begin{lstlisting}
#include <iostream> 
using namespace std; 
int main() {
	double t = true; 
	cout << !t << endl; // dit geeft dus false (0) 
	double x = 3.2; 
	double y = 4.5; 
	cout << (x != y) << endl; // dit gaf net false, nu geeft het true (1)! 
}
\end{lstlisting}
\paragraph{Opdrachten} 
\begin{enumerate}
\item 
Test of de sinus van $\pi/2$ en de cosinus van $\pi/2$ gelijk zijn aan elkaar.
\item
Test ook of de sinus van $\pi/4$ en de cosinus van $\pi/4$ gelijk zijn aan elkaar.
\end{enumerate} 
\subsection{Console invoer}
Het is soms ook handig om juist invoer van de gebruiker te lezen. Daarvoor hebben we \icode{cin}, console-in. Hieronder lezen we een getal in dat we in de variabele \icode{leeftijd} stoppen. De pijltjes staan hier naar rechts, omdat het getal uit de console komt en in de variabele wordt gestopt. We kunnen ook naar een string lezen in plaats van naar een getal. De syntax is: \\

\icode{cin >> } \emph{variabele met het type dat je wilt lezen} \icode{;}\\

Bijvoorbeeld:

\code{code/cin.cpp}
\paragraph{Opdrachten}
\begin{enumerate}
	\item Print op een nieuwe regel de leeftijd die je over een jaar hebt, door \icode{leeftijd + 1} te gebruiken in plaats van \icode{leeftijd}.
		Test het programma door het uit te voeren en in de console je leeftijd in te voeren en op enter te drukken.
	\item
		Als je nu voor je leeftijd een getal invult dat niet geheel is, zul je zien dat deze naar beneden wordt afgerond. Dat komt doordat we de leeftijd opslaan als \icode{int}, en een integer is altijd geheel.
		In plaats van een \icode{int}, kunnen we \icode{leeftijd} ook een \icode{double} maken, zodat hij niet geheel meer hoeft te zijn. Doe dat, en kijk wat er gebeurt als je nu bijvoorbeeld $1$, $2.3$, $1234.345$ en $-1234$ invult in de console.
\end{enumerate}


\subsection{If}
Tot nu toe lag het altijd precies vast welke code werd uitgevoerd en hoe vaak dat gebeurde. Het is ook mogelijk om iets alleen uit te voeren als aan een bepaalde voorwaarde is voldaan. Daarvoor gebruiken we het \icode{if}-statement. De syntax is
\lstset{moredelim=[is][\itshape]{[}{]}}
\begin{lstlisting}
if([conditie]){
	//code wanneer conditie waar (true) is;
} else {
	//code wanneer conditie niet waar (false) is;
}
\end{lstlisting}
Hierin is \icode{conditie} een expressie die tot een boolean evalueert, en dus waar (\icode{true}) of onwaar (\icode{false}) is. Voorbeelden zijn bijvoorbeeld \icode{if(i == 1)} en \icode{if(i < 10)}, waarbij $i$ een integer is. 

Soms hoeven we alleen maar iets te doen als de conditie waar is. In dat geval kunnen we ook de syntax
\begin{lstlisting}
if([conditie]){
	// code wanneer de conditie waar is;
}
\end{lstlisting}
gebruiken.

In het volgende voorbeeld hangt de uitvoer van het programma af van de invoer van de gebruiker.

\code{code/if.cpp}

\paragraph{Opdrachten}
\begin{enumerate}
		\item
		Kan je er voor zorgen dat de twee gevallen uit het voorbeeld verwisseld worden? Dus dat de \icode{true} case nu \icode{"Je bent nog een kind!"} print en de \icode{false} case juist \icode{"Je bent volwassen!"}.
		\item
			Print nu de string \icode{"Je mag nu autorijden!"} wanneer de leeftijd precies 18 jaar is. Hierbij heb je dus geen \icode{else} nodig.
		\item
			Bepaal nu of de leeftijd kleiner is dan 18, tussen de 18 en 65 is, of dat hij minstens 65 is. In het laatste geval moet je \icode{"U bent gepensioneerd!"} schrijven naar de console.
		\item
			Voor herhaalde \icode{if}-statements is er de syntax
\begin{lstlisting}
if(conditie 1){
	// code wanneer conditie 1 waar is;
} else if(conditie 2){
	// code wanneer conditie 1 niet waar is, maar 2 wel;
} else {
	// code wanneer geen van beiden waar is.
}
\end{lstlisting}
Gebruik dit nu voor de code van de vorige opdracht.
\end{enumerate}


\subsection{For}
Als je een stukje code vaker dan \'e\'en keer wilt uitvoeren, kan je hem natuurlijk een aantal keer onder elkaar kopi\"eren en plakken. Als het aantal keer dat je iets wilt doen niet vast ligt, is dat niet meer handig\footnote{Merk op dat het nooit verstandig is om te kopi\"eren en plakken. Ook als je iets maar twee keer moet doen, kan dat prima met een \icode{for} loop}. Daarvoor is de \icode{for}-loop.
Deze herhaalt iets een bepaald aantal keer. Het kan ook zo zijn dat het aantal keer dat iets herhaald wordt nog niet van tevoren vast ligt. De syntax is 
\begin{lstlisting}
for([initialisatie]; [conditie]; [verhoging]){
	//code die herhaald wordt
}
\end{lstlisting}
De \icode{for}-loop heeft een teller-variabele die voor iedere iteratie (herhaling) van de loop wordt opgehoogd. We zullen stap voor stap bekijken hoe een \icode{for}-loop werkt:

\begin{enumerate}
	\item De initialisatie wordt uitgevoerd. Hierbij krijgt de teller zijn beginwaarde, bijvoorbeeld \icode{int i = 0;}. De initialisatie wordt alleen voor de allereerste iteratie uitgevoerd. De teller hoeft overigens niet per se \icode{i} te heten, maar wordt wel vaak \icode{i} genoemd. 
	\item Er wordt gecontroleerd of de conditie \icode{true} is (meestal hangt de conditie van de teller af). Dit werkt op dezelfde manier als de conditie bij het \icode{if}-statement, dus de conditie is een boolean waarde die bepaalt hoe lang de \icode{for}-loop doorgaat. De conditie is vaak iets als \icode{i < 10}. Als de conditie \icode{true} is, gaat het programma verder met de stappen hieronder. Als de conditie \icode{false} is wordt de for-loop afgebroken. 
	\item De code die tussen de accolades staat wordt uitgevoerd. Dit kan van alles zijn. 
	\item De teller wordt opgehoogd. Vaak wordt de teller met \'e\'en opgehoogd, door middel van \icode{i++}, wat equivalent is met \icode{i+=1} en \icode{i=i+1}. Je kunt de teller bijvoorbeeld ook met 2 verlagen, wat je kunt doen met \icode{i-=2} of \icode{i=i-2}.
	\item Stap 2 t/m 4 worden herhaald net zo lang totdat bij een bepaalde iteratie de conditie bij 2 niet meer \emph{true} is. De for-loop is dan ten einde. 
\end{enumerate}

Als je de kleine voorbeelden die hierboven stonden combineert dan zie je dat: \icode{i} begint op 0 en wordt net zo lang met 1 verhoogd totdat hij niet langer kleiner is dan 10. Voor al deze iteraties wordt de code tussen de accolades uitgevoerd, in dit geval gebeurt dat dus 10 keer. Het is handig om te onthouden dat als je iets $n$ keer wilt uitvoeren dat je je \icode{for}-loop dan moet laten beginnen bij \icode{i = 0} en moet laten lopen tot \icode{i < n}. Je kunt de teller natuurlijk ook laten lopen van \icode{i = 1} tot \icode{i <= n}, maar als je verder gaat met programmeren zul je merken dat de eerste versie vaak handiger werkt, dus ik raad je aan om die aan te houden.

Hieronder staat dezelfde uitleg nog een keer, maar dan in code in plaats van in woorden. In het algemeen is de code van een \icode{for}-loop equivalent aan
\begin{lstlisting}
initialisatie;
if(conditie){
	//code die herhaald wordt
	verhoging;
	if(conditie){
		//code die herhaald wordt
		verhoging;
		if(conditie){
			//code die herhaald wordt
			verhoging;
			if(conditie){
				// oneindig lang door
			}
		}
	}
}
\end{lstlisting}
Hier is een voorbeeld van het gebruik van \icode{for}.

\code{code/for.cpp}

Als je dit intikt en uitvoert, zie je dat er eerst drie keer `hoera' wordt geschreven, en daarna de getallen van $0$ tot en met $10$.

\paragraph{Opdrachten}
\begin{enumerate}
	\item
		Print nu 5 keer \icode{"hoera"} op een nieuwe regel.
    \item 
        Print nu alle getallen van 0 tot en met 10 \textit{van groot naar klein}.
	\item
		Doe nu hetzelfde, maar sla dan het getal 3 over. Dit kan je doen met een \icode{if}-statement.
	\item
		Schrijf nu alleen de even getallen tot en met 10 op.
	\item[Bonus] 
		Je kan een getal ook overslaan door \icode{continue} te gebruiken.
		Probeer eens op internet op te zoeken hoe dit werkt, en pas het toe.
	\item
		Bekijk nog eens de code uit de inleiding, en probeer te achterhalen wat het doet en hoe het werkt.
\end{enumerate}

\clearpage
\clearpage
\subsection{Tips: Hoe nu verder?}
In twee uur kunnen we je helaas niet alles leren wat er te leren valt over \cpp, dus hier komen een aantal tips die je kunt gebruiken als je zelfstandig verder wilt gaan met leren programmeren in \cpp. 
\begin{itemize}
	\item Raak niet in paniek als je foutmeldingen krijgt, ook niet als het er heel veel zijn. Het is heel normaal om fouten te maken (bijvoorbeeld typefouten) en dit is hoe de compiler je waarschuwt voor deze fouten. Bij een foutmelding staan altijd twee getallen vermeld: eerst het regelnummer en dan het kolumnummer waar de fout optreed, dit helpt je om de fout te zoeken. Als je niet weet wat een bepaalde foutmelding betekent kun je deze googlen.
	\item Soms kan het gebeuren dat je een foutmelding toch niet kan vinden, ondanks het regelnummer dat staat aangegeven bij de foutmelding. Het kan handig zijn om dan specifieke delen van je programma waarvan je vermoedt dat ze de fout veroorzaken even uit te zetten met behulp van commentaar (dus \icode{//} of \icode{/* */}) om te testen of die regels de foutmelding veroorzaken. 
	\item Er is ontzettend veel te vinden over \cpp (en ook andere programmeertalen) op internet. Eigenlijk is er maar \'e\'en goede tactiek als je nog meer wilt leren: google je suf!\footnote{
			Ook ik (Ragnar) google tijdens het programmeren ruim 10 keer per uur naar kleine dingen. Als je iets even niet meer precies weet: meteen opzoeken. Op die manier moet je dingen soms meerdere keren opzoeken, maar uiteindelijk onthoud je ze vanzelf.
		}
	\item Handige links zijn onder andere:
		\begin{enumerate}
				\item
					\url{http://stackoverflow.com}, een erg groot forum waar op al je vragen een antwoord te vinden is.
					Meestal zijn dit de nuttige resultaten die je via google vindt.
				\item
					\url{http://cppreference.com}, een online \cpp documentatie. Dit is vooral handig als je wilt weten wat een functie, waarvan je de naam al weet, precies doet.
				\item 
					\url{http://cplusplus.com}, een andere documentatie, probeer ze allebei, en kijk welke je fijner vindt.
	\end{enumerate}
	\item Als je een compiler wilt installeren op een Windows computer dan zijn handige alternatieven: Code::Blocks en Visual Studio. Er zijn van Visual Studio ook gratis versies voor studenten\footnote{Deze is verkrijgbaar via DreamSpark: ga naar \url{students.uu.nl/en/free-software} en klik ``Microsoft Software''.}.
		Voor Linux computers is \emph{g++} de meest gebruikte compiler. Meestal wordt deze standaard meegeÃ¯nstalleerd, en hoef je in de terminal alleen maar \mono{g++ programma.cpp} in te tikken. De uitvoer heet dan \mono{a.out}.
	\item Als je twijfelt of je berekeningen goed gaan kan het handig zijn om als tussenstappen de waarde van een variabele te printen met \icode{cout}. Er is ook nog \icode{cerr}, wat speciaal gemaakt is voor errors, maar verder op precies dezelfde manier gebruikt wordt.
	\item Als het je leuk lijkt om een programmeervak te gaan volgen, kun je eens naar deze vakken gaan kijken: bij natuurkunde `Numerieke Methoden' (C en Mathematica), bij wiskunde `Programmeren in de wiskunde' (Python) en bij informatica `Imperatief programmeren' (C\#, eerstejaarsvak, dus goed te doen voor natuurkundigen ook!). Geen van deze vakken wordt in \cpp gegeven, maar ze worden wel in soortgelijke talen gegeven. Als je eenmaal in een taal kunt programmeren is het heel makkelijk om over te stappen naar een andere taal, dus ook deze vakken kunnen je uiteindelijk zeker helpen om beter te worden in \cpp. 
	\item We hebben express te veel opdrachten gemaakt voor vandaag, dus niet getreurd, je kunt thuis gewoon verder gaan met oefenen! Daarnaast zijn er op het internet ook heel veel beginnersopdrachten in \cpp te vinden. Kijk bijvoorbeeld eenss op: \url{http://www.worldbestlearningcenter.com/index_files/cpp-tutorial-variables_datatypes_exercises.htm}.
\end{itemize}

\end{document}
